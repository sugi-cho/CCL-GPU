#pragma kernel buildLabel
#pragma kernel updateLabel
#pragma kernel margeLabel
#pragma kernel margeBoundary
#pragma kernel edging
#pragma kernel clearLabelFlag
#pragma kernel setLabelFlag
#pragma kernel countLabel
#pragma kernel getLabeledPoint

struct pointData
{
    int label;
    int2 pos;
};

Texture2D<float> InTex;
RWTexture2D<float> OutTex;

RWStructuredBuffer<int> LabelFlag;
AppendStructuredBuffer<int> LabelAppend;
AppendStructuredBuffer<pointData> PointAppend;

float threshold;
uint texWidth;
uint texHeight;
int numLabels;

[numthreads(8, 8, 1)]
void buildLabel(uint3 id : SV_DispatchThreadID)
{
    uint2 idx = id.xy;
    uint labelIdx = idx.x + (idx.y * texWidth);
    float val = InTex[idx];
    OutTex[idx] = (0 < val) ? labelIdx + 1 : 0;
    //ラベル値は1~、0は、何もない領域として扱う
}

[numthreads(8, 8, 1)]
void updateLabel(uint3 id : SV_DispatchThreadID)
{
    uint2 idx = id.xy;
    int label = InTex[idx];
    if (0 < label)
    {
        for (int y = 0; y < 3; y++)
            for (int x = 0; x < 3; x++)
            {
                int l = InTex[idx + int2(x - 1, y - 1)];
                label = (0 < l) ? min(label, l) : label;
            }
    }
    OutTex[idx] = label;
}

[numthreads(8, 8, 1)]
void margeLabel(uint3 id : SV_DispatchThreadID)
{
    uint2 idx = id.xy;
    int label = InTex[idx];

    if (0 < label)
    {
        uint2 nextLabelIdx = (uint2) 0;
        int nextLabel = label;
        do
        {
            label = nextLabel;
            nextLabelIdx = uint2(fmod(label - 1, texWidth), (label - 1) / texWidth);
            nextLabel = InTex[nextLabelIdx];
        } while (label != nextLabel);
    }
    OutTex[idx] = label;
}

[numthreads(8, 8, 1)]
void margeBoundary(uint3 id : SV_DispatchThreadID)
{
    uint2 idx = id.xy;
    int label = InTex[idx];
    int oldLabel = label;
    uint2 labeledIdx = uint2(fmod(label - 1, texWidth), (label - 1) / texWidth);
    if (0 < label)
    {
        for (int y = 0; y < 3; y++)
            for (int x = 0; x < 3; x++)
            {
                int l = InTex[idx + int2(x - 1, y - 1)];
                label = (0 < l) ? min(label, l) : label;
            }
        if (label < oldLabel)
            OutTex[labeledIdx] = label;
    }
}

[numthreads(8,8,1)]
void edging(uint3 id : SV_DispatchThreadID)
{
    uint2 idx = id.xy;
    int label = InTex[idx];
    if (0 < label)
    {
        int count = 0;
        for (int y = 0; y < 3; y++)
            for (int x = 0; x < 3; x++)
            {
                int l = InTex[idx + int2(x - 1, y - 1)];
                count += 0 < l;
            }
        label *= saturate(6 - count);
    }
    OutTex[idx] = label;
}

[numthreads(8, 1, 1)]
void clearLabelFlag(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    LabelFlag[idx] = 0;
}

[numthreads(8, 8, 1)]
void setLabelFlag(uint3 id : SV_DispatchThreadID)
{
    uint2 idx = id.xy;
    int label = InTex[idx];
    if (0 < label)
        LabelFlag[label - 1] = label;
}

[numthreads(8, 1, 1)]
void countLabel(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    int label = LabelFlag[idx];
    if (0 < label)
        LabelAppend.Append(label);
}

[numthreads(8, 8, 1)]
void getLabeledPoint(uint3 id : SV_DispatchThreadID)
{
    uint2 idx = id.xy;
    if (0 < InTex[idx])
    {
        pointData data;
        data.label = InTex[idx];
        data.pos = idx;
        PointAppend.Append(data);
    }
}